<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>作品展示目錄</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				color: white;
			}
			body {
				background-color: black;
			}
			canvas {
				display: block;
			}

			.card {
				position: absolute;
				top: 0;
				left: 0;
				font-size: 1.5rem;
				font-family: 'Microsoft JhengHei', sans-serif;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<canvas id="cover"></canvas>
		<div class="card" id="go">圍棋</div>
		<div class="card" id="menu-sur">選單</div>
		<div class="card" id="scroll-ani">滾輪特效(動畫)</div>
		<div class="card" id="scroll-sli">滾輪特效(投影片)</div>

		<script>
			/** @type {HTMLCanvasElement} */
			const cover = document.getElementById('cover')
			const coverCtx = cover.getContext('2d')

			const go = document.getElementById('go')
			const menuSur = document.getElementById('menu-sur')
			const scrollAni = document.getElementById('scroll-ani')
			const scrollSli = document.getElementById('scroll-sli')

			const POINT_SIZE = 10
			const MAX_POINTS = 36
			const MAX_DISTANCE = 250

			const goSidePoint = Math.sqrt(MAX_POINTS)
			const menuSidePoint = (MAX_POINTS - 6) / 3

			class Point {
				constructor(size) {
					this.overflow = this.rebound
					this.move = true
					this.size = size
					this.x = getRandom(size, window.innerWidth - size)
					this.y = getRandom(size, window.innerHeight - size)
					this.speedX = getRandom(-50, 50)
					this.speedY = getRandom(-50, 50)
					this.lastTime = Date.now()
				}

				/**
				 * @param {number} x 目標x座標
				 * @param {number} y 目標y座標
				 */

				rebound() {
					if (this.x < this.size / 2) {
						this.x = this.size / 2
						this.speedX = -this.speedX
					}
					if (this.x > cover.width - this.size / 2) {
						this.x = cover.width - this.size / 2
						this.speedX = -this.speedX
					}
					if (this.y < this.size / 2) {
						this.y = this.size / 2
						this.speedY = -this.speedY
					}
					if (this.y > cover.height - this.size / 2) {
						this.y = cover.height - this.size / 2
						this.speedY = -this.speedY
					}
				}
				arroundY() {
					if (this.x < this.size / 2) {
						this.x = this.size / 2
						this.speedX = -this.speedX
					}
					if (this.x > cover.width - this.size / 2) {
						this.x = cover.width - this.size / 2
						this.speedX = -this.speedX
					}
					if (this.y < this.size / 2) {
						this.y = cover.height - this.size / 2
					}
					if (this.y > cover.height - this.size / 2) {
						this.y = this.size / 2
					}
				}

				specDraw(x, y) {
					const offsetTime = (Date.now() - this.lastTime) / 500
					const _x = x - this.x
					const _y = y - this.y

					this.x = Math.abs(_x) > 0.1 ? this.x + _x * offsetTime : x
					this.y = Math.abs(_y) > 0.1 ? this.y + _y * offsetTime : y

					this._draw()
				}
				randDraw() {
					if (this.move) {
						this.overflow()

						const offsetTime = (Date.now() - this.lastTime) / 1000
						this.x += this.speedX * offsetTime
						this.y += this.speedY * offsetTime
					}
					this._draw()
				}

				_draw() {
					coverCtx.beginPath()
					coverCtx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2)
					coverCtx.fillStyle = '#fff'
					coverCtx.fill()

					this.lastTime = Date.now()
				}
			}
			class Graph {
				constructor(maxPoints, pointSize, maxDistance) {
					this.drawPoint = { method: 'random', fn: undefined }
					this.maxDistance = maxDistance
					this.maxPoints = maxPoints
					this.points = new Array(maxPoints).fill(0).map(() => {
						return new Point(pointSize)
					})
				}

				changeSpeedX(speed) {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedX = speed
					}
				}
				changeSpeedY(speed) {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedY = speed
					}
				}
				recoverySpeed() {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedX = getRandom(-50, 50)
						this.points[p].speedY = getRandom(-50, 50)
					}
				}

				/**
				 * @param {String} method rebound: 反彈, arroundY: Y軸環繞, arroundX: X軸環繞
				 */
				overflow(method) {
					for (let p = 0; p < this.maxPoints; p++) {
						if (method === 'rebound') {
							this.points[p].overflow = this.points[p].rebound
						}
						if (method === 'arroundY') {
							this.points[p].overflow = this.points[p].arroundY
						}
					}
				}

				/**
				 * @param {String} formation go: 正四方實心隊形, menu: 垂直矩形中空靠左隊形
				 * @param {Number} width 關鍵邊長的長度
				 */
				align(formation, width) {
					if (formation === 'go') {
						this.drawPoint.method = 'specific'
						this.drawPoint.fn = () => {
							const min = Math.min(cover.width, cover.height)
							const gap = min / (width + 1)
							let marginX = 0
							let marginY = 0
							if (min === cover.width) {
								marginX = gap
								marginY = (cover.height - gap * (width - 1)) / 2
							} else {
								marginX = (cover.width - gap * (width - 1)) / 2
								marginY = gap
							}
							for (let y = 0; y < width; y++) {
								for (let x = 0; x < width; x++) {
									const _x = marginX + x * gap
									const _y = marginY + y * gap
									this.points[y * width + x].specDraw(_x, _y)
								}
							}
						}
					}

					//去頭去尾去第二，剩餘三角排列
					if (formation === 'menu') {
						this.drawPoint.method = 'specific'
						this.drawPoint.fn = () => {
							const _h = width * 2 + 3
							const gap = cover.height / (_h + 1)
							const marginY = gap / 2
							const marginX = gap * 3
							for (let y = 0; y < _h; y++) {
								for (let x = 0; x < 2; x++) {
									const _isOdd = y % 2 !== 0
									if (y === 0 || y === _h - 1) {
										const _x = marginX + (1 + x * 2) * gap
										const _y = marginY + y * gap
										let i = undefined

										if (y === 0) i = 0
										else i = Math.ceil(y * 1.5) + 1
										this.points[i + x].specDraw(_x, _y)
									} else if (y === 1) {
										const _x = marginX + x * 4 * gap
										const _y = marginY + gap
										this.points[2 + x].specDraw(_x, _y)
									} else {
										if (!_isOdd) {
											const _x = marginX + gap * 2
											const _y = marginY + gap * y
											const i =
												4 + Math.ceil((y - 2) * 1.5)
											this.points[i].specDraw(_x, _y)

											continue
										} else {
											const _x = marginX + x * 4 * gap
											const _y = marginY + gap * y
											const i =
												5 + Math.floor((y - 3) * 1.5)
											this.points[i + x].specDraw(_x, _y)
										}
									}
								}
							}
						}
					}
				}
				random() {
					this.drawPoint = { method: 'random', fn: undefined }
				}

				draw() {
					coverCtx.clearRect(0, 0, cover.width, cover.height)
					requestAnimationFrame(() => {
						return this.draw()
					})

					for (let s = 0; s < this.maxPoints; s++) {
						for (let e = s + 1; e < this.maxPoints; e++) {
							this._drawLine(s, e)
						}
					}

					if (this.drawPoint.method === 'random') {
						for (let s = 0; s < this.maxPoints; s++) {
							this.points[s].randDraw()
						}
					}
					if (this.drawPoint.method === 'specific') {
						this.drawPoint.fn()
					}
				}

				animateStart() {
					this.draw()
					for (let s = 0; s < this.maxPoints; s++) {
						this.points[s].move = true
					}
				}
				animateStop() {
					for (let s = 0; s < this.maxPoints; s++) {
						this.points[s].move = false
					}
				}

				/**
				 * @param {number} start 起始的points[索引]
				 * @param {number} end 結束的points[索引]
				 */
				_drawLine(start, end) {
					const _x = this.points[start].x - this.points[end].x
					const _y = this.points[start].y - this.points[end].y
					const distance = Math.sqrt(
						Math.abs(_x ** 2) + Math.abs(_y ** 2)
					)
					const opacity = 1 - distance / this.maxDistance

					coverCtx.beginPath()
					coverCtx.moveTo(this.points[start].x, this.points[start].y)
					coverCtx.lineTo(this.points[end].x, this.points[end].y)
					coverCtx.closePath()
					coverCtx.lineWidth = 1
					coverCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`
					coverCtx.stroke()
				}
			}

			function getRandom(min, max) {
				return Math.floor(Math.random() * (max - min - 1) + min)
			}

			const graph = new Graph(MAX_POINTS, POINT_SIZE, MAX_DISTANCE)
			CoverInit()
			function CoverInit() {
				cover.width = window.innerWidth
				cover.height = window.innerHeight
				if (window.innerHeight < document.documentElement.scrollHeight)
					cover.width -= 17
				graph.animateStart()

				const coverX = cover.clientWidth
				const coverY = cover.clientHeight
				go.style.top =
					getRandom(50, coverY - go.clientHeight - 50) + 'px'
				go.style.left =
					getRandom(50, coverX - go.clientWidth - 50) + 'px'
				ElementAni(go)
				menuSur.style.top =
					getRandom(50, coverY - menuSur.clientHeight - 50) + 'px'
				menuSur.style.left =
					getRandom(50, coverX - menuSur.clientWidth - 50) + 'px'
				ElementAni(menuSur)
				scrollAni.style.top =
					getRandom(50, coverY - scrollAni.clientHeight - 50) + 'px'
				scrollAni.style.left =
					getRandom(50, coverX - scrollAni.clientWidth - 50) + 'px'
				ElementAni(scrollAni)
				scrollSli.style.top =
					getRandom(50, coverY - scrollSli.clientHeight - 50) + 'px'
				scrollSli.style.left =
					getRandom(50, coverX - scrollSli.clientWidth - 50) + 'px'
				ElementAni(scrollSli)
			}

			function ElementAni(target) {
				// 之後再說
			}

			go.onclick = () => {
				window.location = './Go'
			}
			go.onmouseenter = () => {
				graph.align('go', goSidePoint)
			}
			go.onmouseleave = () => {
				graph.random()
			}
			menuSur.onclick = () => {
				window.location = './Menu/Surround/'
			}
			menuSur.onmouseenter = () => {
				graph.align('menu', menuSidePoint)
			}
			menuSur.onmouseleave = () => {
				graph.random()
			}
			scrollAni.onclick = () => {
				window.location = './Scrolling%20Effect/Animation/'
			}
			scrollAni.onmouseenter = () => {
				graph.overflow('arroundY')
				graph.changeSpeedY(-100)
			}
			scrollAni.onmouseleave = () => {
				graph.overflow('rebound')
				graph.recoverySpeed()
			}
			scrollSli.onclick = () => {
				window.location = './Scrolling%20Effect/Slideshow/'
			}
			scrollSli.onmouseenter = () => {
				graph.overflow('arroundY')
				graph.changeSpeedY(-100)
			}
			scrollSli.onmouseleave = () => {
				graph.overflow('rebound')
				graph.recoverySpeed()
			}
		</script>
	</body>
</html>

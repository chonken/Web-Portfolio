<!DOCTYPE html>
<html lang="zh-Hant-TW">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>作品展示目錄</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				color: white;
			}
			body {
				background-color: black;
			}
			canvas {
				display: block;
				width: 100%;
				height: 100vh;
			}

			.cover {
				position: relative;
				overflow: hidden;
			}
			.cover .card {
				position: absolute;
				top: 0;
				left: 0;
				font-size: 1.5rem;
				font-family: 'Microsoft JhengHei', sans-serif;
				cursor: pointer;
			}

			/* test */
			div:not(.card) {
				min-height: 500px;
				min-width: 1px;
			}
		</style>
	</head>
	<body>
		<header></header>
		<main>
			<div class="cover">
				<canvas id="cover"></canvas>
				<!-- <div class="card" id="go">圍棋</div>
				<div class="card" id="minesweeper">踩地雷</div>
				<div class="card" id="fireworks">煙火特效</div>
				<div class="card" id="scroll-ani">滾輪特效(動畫)</div>
				<div class="card" id="scroll-sli">滾輪特效(投影片)</div>
				<div class="card" id="menu-sur">選單</div>
				<div class="card" id="web">網頁</div> -->
				<div id="_game" class="card">遊戲</div>
				<div id="_canvas" class="card">Canvas</div>
				<div id="_scroll" class="card">滾輪特效</div>
				<div id="_menu" class="card">選單動畫</div>
				<div id="_web" class="card">復刻網頁</div>
			</div>
			<div id="game" class="game"></div>
			<div id="canvas" class="canvas"></div>
			<div id="scroll" class="scroll"></div>
			<div id="menu" class="menu"></div>
			<div id="web" class="web"></div>
		</main>
		<footer></footer>

		<script>
			/** @type {HTMLCanvasElement} */
			const cover = document.getElementById('cover')
			const coverCtx = cover.getContext('2d')

			const cards = document.querySelectorAll('.card')
			// const go = document.getElementById('go')
			// const minesweeper = document.getElementById('minesweeper')
			// const fireworks = document.getElementById('fireworks')
			// const menuSur = document.getElementById('menu-sur')
			// const scrollAni = document.getElementById('scroll-ani')
			// const scrollSli = document.getElementById('scroll-sli')
			// const web = document.getElementById('web')

			const POINT_SIZE = 10
			const MAX_POINTS = 36
			const MAX_DISTANCE = 250

			const goSidePoint = Math.sqrt(MAX_POINTS)
			const menuSidePoint = (MAX_POINTS - 6) / 3

			class Point {
				constructor(size) {
					this.overflow = this.rebound
					this.move = true
					this.size = size
					this.x = getRandom(size, window.innerWidth - size)
					this.y = getRandom(size, window.innerHeight - size)
					this.speedX = getRandom(-50, 50)
					this.speedY = getRandom(-50, 50)
					this.lastTime = Date.now()
				}

				/**
				 * @param {number} x 目標x座標
				 * @param {number} y 目標y座標
				 */

				rebound() {
					if (this.x < this.size / 2) {
						this.x = this.size / 2
						this.speedX = -this.speedX
					}
					if (this.x > cover.width - this.size / 2) {
						this.x = cover.width - this.size / 2
						this.speedX = -this.speedX
					}
					if (this.y < this.size / 2) {
						this.y = this.size / 2
						this.speedY = -this.speedY
					}
					if (this.y > cover.height - this.size / 2) {
						this.y = cover.height - this.size / 2
						this.speedY = -this.speedY
					}
				}
				arroundY() {
					if (this.x < this.size / 2) {
						this.x = this.size / 2
						this.speedX = -this.speedX
					}
					if (this.x > cover.width - this.size / 2) {
						this.x = cover.width - this.size / 2
						this.speedX = -this.speedX
					}
					if (this.y < this.size / 2) {
						this.y = cover.height - this.size / 2
					}
					if (this.y > cover.height - this.size / 2) {
						this.y = this.size / 2
					}
				}

				specDraw(x, y) {
					const offsetTime = (Date.now() - this.lastTime) / 500
					const _x = x - this.x
					const _y = y - this.y

					this.x = Math.abs(_x) > 0.1 ? this.x + _x * offsetTime : x
					this.y = Math.abs(_y) > 0.1 ? this.y + _y * offsetTime : y

					this._draw()
				}
				randDraw() {
					if (this.move) {
						this.overflow()

						const offsetTime = (Date.now() - this.lastTime) / 1000
						this.x += this.speedX * offsetTime
						this.y += this.speedY * offsetTime
					}
					this._draw()
				}

				_draw() {
					coverCtx.beginPath()
					coverCtx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2)
					coverCtx.fillStyle = '#fff'
					coverCtx.fill()

					this.lastTime = Date.now()
				}
			}
			class Graph {
				constructor(maxPoints, pointSize, maxDistance) {
					this.drawPoint = { method: 'random', fn: undefined }
					this.maxDistance = maxDistance
					this.maxPoints = maxPoints
					this.points = new Array(maxPoints).fill(0).map(() => {
						return new Point(pointSize)
					})
				}

				changeSpeedX(speed) {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedX = speed
					}
				}
				changeSpeedY(speed) {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedY = speed
					}
				}
				recoverySpeed() {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedX = getRandom(-50, 50)
						this.points[p].speedY = getRandom(-50, 50)
					}
				}

				/**
				 * @param {String} method rebound: 反彈, arroundY: Y軸環繞, arroundX: X軸環繞
				 */
				overflow(method) {
					for (let p = 0; p < this.maxPoints; p++) {
						if (method === 'rebound') {
							this.points[p].overflow = this.points[p].rebound
						}
						if (method === 'arroundY') {
							this.points[p].overflow = this.points[p].arroundY
						}
					}
				}

				/**
				 * @param {String} formation go: 正四方實心隊形, menu: 垂直矩形中空靠左隊形
				 * @param {Number} width 關鍵邊長的長度
				 */
				align(formation, width) {
					if (formation === 'go') {
						this.drawPoint.method = 'specific'
						this.drawPoint.fn = () => {
							const min = Math.min(cover.width, cover.height)
							const gap = min / (width + 1)
							let marginX = 0
							let marginY = 0
							if (min === cover.width) {
								marginX = gap
								marginY = (cover.height - gap * (width - 1)) / 2
							} else {
								marginX = (cover.width - gap * (width - 1)) / 2
								marginY = gap
							}
							for (let y = 0; y < width; y++) {
								for (let x = 0; x < width; x++) {
									const _x = marginX + x * gap
									const _y = marginY + y * gap
									this.points[y * width + x].specDraw(_x, _y)
								}
							}
						}
					}

					//去頭去尾去第二，剩餘三角排列
					if (formation === 'menu') {
						this.drawPoint.method = 'specific'
						this.drawPoint.fn = () => {
							const _h = width * 2 + 3
							const gap = cover.height / (_h + 1)
							const marginY = gap / 2
							const marginX = gap * 3
							for (let y = 0; y < _h; y++) {
								for (let x = 0; x < 2; x++) {
									const _isOdd = y % 2 !== 0
									if (y === 0 || y === _h - 1) {
										const _x = marginX + (1 + x * 2) * gap
										const _y = marginY + y * gap
										let i = undefined

										if (y === 0) i = 0
										else i = Math.ceil(y * 1.5) + 1
										this.points[i + x].specDraw(_x, _y)
									} else if (y === 1) {
										const _x = marginX + x * 4 * gap
										const _y = marginY + gap
										this.points[2 + x].specDraw(_x, _y)
									} else {
										if (!_isOdd) {
											const _x = marginX + gap * 2
											const _y = marginY + gap * y
											const i =
												4 + Math.ceil((y - 2) * 1.5)
											this.points[i].specDraw(_x, _y)

											continue
										} else {
											const _x = marginX + x * 4 * gap
											const _y = marginY + gap * y
											const i =
												5 + Math.floor((y - 3) * 1.5)
											this.points[i + x].specDraw(_x, _y)
										}
									}
								}
							}
						}
					}
				}
				random() {
					this.drawPoint = { method: 'random', fn: undefined }
				}

				draw() {
					coverCtx.clearRect(0, 0, cover.width, cover.height)
					requestAnimationFrame(() => {
						return this.draw()
					})

					for (let s = 0; s < this.maxPoints; s++) {
						for (let e = s + 1; e < this.maxPoints; e++) {
							this._drawLine(s, e)
						}
					}

					if (this.drawPoint.method === 'random') {
						for (let s = 0; s < this.maxPoints; s++) {
							this.points[s].randDraw()
						}
					}
					if (this.drawPoint.method === 'specific') {
						this.drawPoint.fn()
					}
				}

				animateStart() {
					this.draw()
					for (let s = 0; s < this.maxPoints; s++) {
						this.points[s].move = true
					}
				}
				animateStop() {
					for (let s = 0; s < this.maxPoints; s++) {
						this.points[s].move = false
					}
				}

				/**
				 * @param {number} start 起始的points[索引]
				 * @param {number} end 結束的points[索引]
				 */
				_drawLine(start, end) {
					const _x = this.points[start].x - this.points[end].x
					const _y = this.points[start].y - this.points[end].y
					const distance = Math.sqrt(
						Math.abs(_x ** 2) + Math.abs(_y ** 2)
					)
					const opacity = 1 - distance / this.maxDistance

					coverCtx.beginPath()
					coverCtx.moveTo(this.points[start].x, this.points[start].y)
					coverCtx.lineTo(this.points[end].x, this.points[end].y)
					coverCtx.closePath()
					coverCtx.lineWidth = 1
					coverCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`
					coverCtx.stroke()
				}
			}

			function getRandom(min, max) {
				return Math.floor(Math.random() * (max - min + 1) + min)
			}

			const graph = new Graph(MAX_POINTS, POINT_SIZE, MAX_DISTANCE)
			const position = {} // { element: { top, bottom, width, height }, ... }
			CoverInit()
			function CoverInit() {
				cover.width = window.innerWidth
				cover.height = window.innerHeight

				graph.animateStart()

				const coverX = cover.clientWidth
				const coverY = cover.clientHeight
				// go.style.top =
				// 	getRandom(50, coverY - go.clientHeight - 50) + 'px'
				// go.style.left =
				// 	getRandom(50, coverX - go.clientWidth - 50) + 'px'
				// ElementAni(go)
				// minesweeper.style.top =
				// 	getRandom(50, coverY - minesweeper.clientHeight - 50) + 'px'
				// minesweeper.style.left =
				// 	getRandom(50, coverX - minesweeper.clientWidth - 50) + 'px'
				// fireworks.style.top =
				// 	getRandom(50, coverY - fireworks.clientHeight - 50) + 'px'
				// fireworks.style.left =
				// 	getRandom(50, coverX - fireworks.clientWidth - 50) + 'px'
				// menuSur.style.top =
				// 	getRandom(50, coverY - menuSur.clientHeight - 50) + 'px'
				// menuSur.style.left =
				// 	getRandom(50, coverX - menuSur.clientWidth - 50) + 'px'
				// ElementAni(menuSur)
				// scrollAni.style.top =
				// 	getRandom(50, coverY - scrollAni.clientHeight - 50) + 'px'
				// scrollAni.style.left =
				// 	getRandom(50, coverX - scrollAni.clientWidth - 50) + 'px'
				// ElementAni(scrollAni)
				// scrollSli.style.top =
				// 	getRandom(50, coverY - scrollSli.clientHeight - 50) + 'px'
				// scrollSli.style.left =
				// 	getRandom(50, coverX - scrollSli.clientWidth - 50) + 'px'
				// ElementAni(scrollSli)
				// web.style.top =
				// 	getRandom(50, coverY - web.clientHeight - 50) + 'px'
				// web.style.left =
				// 	getRandom(50, coverX - web.clientWidth - 50) + 'px'

				cards.forEach((element) => {
					const x = getRandom(
						50,
						cover.clientWidth - element.offsetWidth - 50
					)
					const y = getRandom(
						50,
						cover.clientHeight - element.offsetHeight - 50
					)
					element.style.transform = `translate(${x}px, ${y}px)`
					const _c = {
						top: y,
						left: x,
						width: element.offsetWidth,
						height: element.offsetHeight,
					}
					position[element.id] = _c

					element.onclick = () => {
						location = '#' + element.id.slice(1)
					}
					element.onmouseenter = () => {
						graph.align(element.id, goSidePoint)
					}
					element.onmouseleave = () => {
						graph.random()
					}
				})
				ElementAni()
			}

			function ElementAni() {
				const SPEED = 50
				let lastTime = Date.now()
				const animate = {
					state: true,
					stop() {
						if (this.state) this.state = false
					},
					start() {
						if (!this.state) {
							this.state = true
							lastTime = Date.now()
							move()
						}
					},
				}
				class Position {
					constructor(target) {
						this.target = target
						this.left = position[target.id].left
						this.top = position[target.id].top
						this.width = position[target.id].width
						this.height = position[target.id].height
						this.signX = getRandom(0, 1) ? -1 : 1
						this.signY = getRandom(0, 1) ? -1 : 1
						this.speedX = getRandom(10, SPEED)
						this.speedY = Math.floor(
							Math.sqrt(SPEED ** 2 - this.speedX ** 2)
						)
					}
					moveX(offsetTime) {
						const clientWidth = document.body.clientWidth
						if (this.left <= 0) {
							this.signX = 1
							this.left = 1
						} else if (this.left >= clientWidth - this.width) {
							this.signX = -1
							this.left = clientWidth - this.width - 1
						} else
							this.left += this.speedX * offsetTime * this.signX

						position[this.target.id].left = this.left
					}
					moveY(offsetTime) {
						if (this.top <= 0) {
							this.signY = 1
							this.top = 1
						} else if (this.top >= cover.height - this.height) {
							this.signY = -1
							this.top = cover.height - this.height - 1
						} else this.top += this.speedY * offsetTime * this.signY

						position[this.target.id].top = this.top
					}
					collider() {
						for (let key in position) {
							if (key === this.target.id) continue

							const value = position[key]
							const _rX =
								_inRange(this.left + this.width, [
									value.left,
									value.left + value.width,
								]) ||
								_inRange(this.left, [
									value.left,
									value.left + value.width,
								])
							const _rY =
								_inRange(this.top, [
									value.top,
									value.top + value.height,
								]) ||
								_inRange(this.top + this.height, [
									value.top,
									value.top + value.height,
								])
							if (_rX && _rY) {
								const r = Math.abs(
									this.left + this.width - value.left
								)
								const l = Math.abs(
									this.left - (value.left + value.width)
								)
								const t = Math.abs(
									this.top - (value.top + value.height)
								)
								const b = Math.abs(
									this.top + this.height - value.top
								)

								const min = Math.min(r, l, t, b)
								if (r === min) {
									this.signX = -1
								} else if (l === min) {
									this.signX = 1
								}
								if (t === min) {
									this.signY = 1
								} else if (b === min) {
									this.signY = -1
								}
							}
						}
					}
				}
				const pos = []

				cards.forEach((target) => {
					pos.push(new Position(target))
				})
				;(function move() {
					if (animate.state) requestAnimationFrame(move)

					const offsetTime = (Date.now() - lastTime) / 1000
					for (const p of pos) {
						p.moveX(offsetTime)
						p.moveY(offsetTime)
						p.collider()
						p.target.style.transform = `translate(${p.left}px, ${p.top}px)`
					}
					lastTime = Date.now()
				})()

				/**
				 * @param {Number} value -
				 * @param {Array} block - [top, bottom] or [left, right]
				 * @returns {Boolean} -
				 */
				function _inRange(value, block) {
					return value >= block[0] && value <= block[1]
				}
			}
			// go.onclick = () => {
			// 	window.location = './Game/Go/'
			// }
			// go.onmouseenter = () => {
			// 	graph.align('go', goSidePoint)
			// }
			// go.onmouseleave = () => {
			// 	graph.random()
			// }
			// minesweeper.onclick = () => {
			// 	window.location = './Game/Minesweeper/'
			// }
			// minesweeper.onmouseenter = () => {
			// 	graph.align('go', goSidePoint)
			// }
			// minesweeper.onmouseleave = () => {
			// 	graph.random()
			// }
			// fireworks.onclick = () => {
			// 	window.location = './Canvas/Fireworks/'
			// }
			// fireworks.onmouseenter = () => {
			// 	graph.overflow('arroundY')
			// 	graph.changeSpeedY(-100)
			// }
			// fireworks.onmouseleave = () => {
			// 	graph.overflow('rebound')
			// 	graph.recoverySpeed()
			// }
			// menuSur.onclick = () => {
			// 	window.location = './Menu/Surround/'
			// }
			// menuSur.onmouseenter = () => {
			// 	graph.align('menu', menuSidePoint)
			// }
			// menuSur.onmouseleave = () => {
			// 	graph.random()
			// }
			// scrollAni.onclick = () => {
			// 	window.location = './Scrolling%20Effect/Animation/'
			// }
			// scrollAni.onmouseenter = () => {
			// 	graph.overflow('arroundY')
			// 	graph.changeSpeedY(-100)
			// }
			// scrollAni.onmouseleave = () => {
			// 	graph.overflow('rebound')
			// 	graph.recoverySpeed()
			// }
			// scrollSli.onclick = () => {
			// 	window.location = './Scrolling%20Effect/Slideshow/'
			// }
			// scrollSli.onmouseenter = () => {
			// 	graph.overflow('arroundY')
			// 	graph.changeSpeedY(-100)
			// }
			// scrollSli.onmouseleave = () => {
			// 	graph.overflow('rebound')
			// 	graph.recoverySpeed()
			// }
			// web.onclick = () => {
			// 	window.location = './WebDemo/Demo1/'
			// }
		</script>
	</body>
</html>

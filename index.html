<!DOCTYPE html>
<html lang="zh-Hant-TW">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="stylesheet" href="./WebDemo/common.css" />
		<title>作品展示目錄</title>
		<style>
			/* 共用 */
			section {
				display: flex;
				flex-direction: column;
				justify-content: center;
				width: 100%;
				min-height: 100vh;
				overflow: hidden;
			}
			.content {
				margin: 30px 0;
			}
			.title {
				margin-bottom: 5vh;
			}
			.title h2 {
				margin-bottom: 8px;
				text-align: center;
				font-size: 2.5rem;
			}
			.title p {
				text-align: center;
				font-size: 1.2rem;
			}
			@media screen and (max-width: 768px) {
				.title h2 {
					font-size: 2rem;
				}
			}
			@media screen and (max-width: 480px) {
				.title h2 {
					font-size: 1.5rem;
				}
				.title p {
					text-align: center;
					font-size: 1.1rem;
				}
			}
			.carousel {
				position: relative;
				/* overflow-x: hidden; */
				border: 1px solid red;
			}
			.carousel li {
				border: 1px solid red;
			}
			.carousel::before {
				content: '';
				position: absolute;
				top: calc(50% - 20px);
				left: -20px;
				width: 40px;
				aspect-ratio: 1/1;
				cursor: pointer;
				border: 1px solid red;
			}
			.carousel::after {
				content: '';
				position: absolute;
				top: calc(50% - 20px);
				right: -20px;
				width: 40px;
				aspect-ratio: 1/1;
				cursor: pointer;
				border: 1px solid red;
			}
			canvas {
				display: block;
				width: 100%;
				height: 100vh;
			}

			/* banner */
			.banner {
				position: relative;
				overflow: hidden;
				background-color: black;
				color: white;
			}
			.banner .card {
				position: absolute;
				top: 0;
				left: 0;
				font-size: 1.5rem;
				font-family: 'Microsoft JhengHei', sans-serif;
				cursor: pointer;
			}

			/* game */
			.game {
				border: 1px solid red;
			}
			.game ul {
				display: flex;
				flex-wrap: nowrap;
			}
			.game li {
				min-width: 25%;
				aspect-ratio: 1/1;
			}
			.game .describe {
				min-height: 150px;
				border: 1px solid red;
			}
			@media screen and (max-width: 1024px) {
				.game li {
					min-width: 33.3%;
				}
			}
			@media screen and (max-width: 768px) {
				.game li {
					min-width: 50%;
				}
				.game .describe {
					display: none;
				}
			}
			@media screen and (max-width: 480px) {
				.game li {
					min-width: 100%;
				}
				.game .carousel::before {
					left: 0;
				}
				.game .carousel::after {
					right: 0;
				}
				.game .describe {
					display: none;
				}
			}

			/* canvas */
			.canvas {
				border: 1px solid red;
			}
			.canvas ul {
				position: relative;
				width: 100%;
				aspect-ratio: calc(16 / (9 * 0.6));
			}
			.canvas li {
				position: absolute;
				top: 0;
				left: 20%;
				width: 60%;
				aspect-ratio: 16/9;
			}
			.canvas .carousel::before {
				display: none;
			}
			.canvas .carousel::after {
				display: none;
			}
			@media screen and (max-width: 768px) {
				.canvas ul {
					aspect-ratio: 16/9;
				}
				.canvas li {
					left: 0;
					width: 100%;
				}
				.canvas .carousel::before {
					left: 0;
					display: block;
				}
				.canvas .carousel::after {
					right: 0;
					display: block;
				}
			}

			/* scroll */
			.scroll {
				border: 1px solid red;
			}
			.scroll ul {
				position: relative;
				width: 100%;
				aspect-ratio: 16/9;
			}
			.scroll li {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				aspect-ratio: 16/9;
			}
			.scroll .carousel::before {
				top: 45%;
				left: 0;
				width: auto;
				height: 15%;
			}
			.scroll .carousel::after {
				top: 45%;
				right: 0;
				width: auto;
				height: 15%;
			}

			/* menu */
			.menu {
				border: 1px solid red;
			}
			.menu .honeycomb {
				border: 1px solid red;
			}

			/* web */
			.web {
				border: 1px solid red;
			}
			.web ul {
				display: flex;
				flex-wrap: nowrap;
			}
			.web li {
				min-width: 33.33%;
				aspect-ratio: 16/18;
			}
			.web .content {
				padding-bottom: 80px;
			}
			.web .carousel::before {
				top: auto;
				bottom: -80px;
				left: calc(50% - 100px);
				width: 60px;
			}
			.web .carousel::after {
				top: auto;
				bottom: -80px;
				right: calc(50% - 100px);
				width: 60px;
			}

			/* 1280up */
			@media screen and (min-width: 1280px) {
				/* sidebar */
			}
		</style>
	</head>
	<body>
		<header></header>
		<main>
			<section class="banner">
				<div class="cover" style="display: none">
					<h1>作品展示</h1>
				</div>
				<canvas id="banner"></canvas>
				<!-- <div class="card" id="go">圍棋</div>
				<div class="card" id="minesweeper">踩地雷</div>
				<div class="card" id="fireworks">煙火特效</div>
				<div class="card" id="scroll-ani">滾輪特效(動畫)</div>
				<div class="card" id="scroll-sli">滾輪特效(投影片)</div>
				<div class="card" id="menu-sur">選單</div>
				<div class="card" id="web">網頁</div> -->
				<div id="_game" class="card">遊戲</div>
				<div id="_canvas" class="card">Canvas</div>
				<div id="_scroll" class="card">滾輪特效</div>
				<div id="_menu" class="card">選單動畫</div>
				<div id="_web" class="card">復刻網頁</div>
			</section>
			<section id="game" class="game">
				<div class="content">
					<div class="title">
						<h2>遊戲</h2>
						<p>圍棋、踩地雷</p>
					</div>
					<div id="crl-slide" class="carousel container">
						<div class="frame hidden-x">
							<ul>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
							</ul>
						</div>
					</div>
					<div class="describe container"></div>
				</div>
			</section>
			<section id="canvas" class="canvas">
				<div class="content">
					<div class="title">
						<h2>Canvas</h2>
						<p>煙火</p>
					</div>
					<div id="crl-focus" class="carousel container">
						<div class="frame hidden-x">
							<ul>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section id="scroll" class="scroll">
				<div class="content">
					<div class="title">
						<h2>滾輪特效</h2>
						<p></p>
					</div>
					<div id="crl-fade" class="carousel container">
						<div class="frame hidden-x">
							<ul>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section id="menu" class="menu">
				<div class="content">
					<div class="title">
						<h2>選單動畫</h2>
						<p></p>
					</div>
					<div class="honeycomb" style="min-height: 300px"></div>
				</div>
			</section>
			<section id="web" class="web">
				<div class="content">
					<div class="title">
						<h2>復刻網頁</h2>
						<p>練習用、無商業用途</p>
					</div>
					<div id="crl-gallery" class="carousel container">
						<div class="frame hidden-x">
							<ul>
								<li></li>
								<li></li>
								<li></li>
								<li></li>
							</ul>
						</div>
					</div>
				</div>
			</section>
		</main>
		<footer></footer>

		<script>
			/** @type {HTMLCanvasElement} */
			const banner = document.getElementById('banner')
			const coverCtx = banner.getContext('2d')

			const cards = document.querySelectorAll('.card')
			// const go = document.getElementById('go')
			// const minesweeper = document.getElementById('minesweeper')
			// const fireworks = document.getElementById('fireworks')
			// const menuSur = document.getElementById('menu-sur')
			// const scrollAni = document.getElementById('scroll-ani')
			// const scrollSli = document.getElementById('scroll-sli')
			// const web = document.getElementById('web')

			const POINT_SIZE = 10
			const MAX_POINTS = 36
			const MAX_DISTANCE = 250

			const goSidePoint = Math.sqrt(MAX_POINTS)
			const menuSidePoint = (MAX_POINTS - 6) / 3

			class Point {
				constructor(size) {
					this.overflow = this.rebound
					this.move = true
					this.size = size
					this.x = getRandom(size, window.innerWidth - size)
					this.y = getRandom(size, window.innerHeight - size)
					this.speedX = getRandom(-50, 50)
					this.speedY = getRandom(-50, 50)
					this.lastTime = Date.now()
				}

				/**
				 * @param {number} x 目標x座標
				 * @param {number} y 目標y座標
				 */

				rebound() {
					if (this.x < this.size / 2) {
						this.x = this.size / 2
						this.speedX = -this.speedX
					}
					if (this.x > banner.width - this.size / 2) {
						this.x = banner.width - this.size / 2
						this.speedX = -this.speedX
					}
					if (this.y < this.size / 2) {
						this.y = this.size / 2
						this.speedY = -this.speedY
					}
					if (this.y > banner.height - this.size / 2) {
						this.y = banner.height - this.size / 2
						this.speedY = -this.speedY
					}
				}
				arroundY() {
					if (this.x < this.size / 2) {
						this.x = this.size / 2
						this.speedX = -this.speedX
					}
					if (this.x > banner.width - this.size / 2) {
						this.x = banner.width - this.size / 2
						this.speedX = -this.speedX
					}
					if (this.y < this.size / 2) {
						this.y = banner.height - this.size / 2
					}
					if (this.y > banner.height - this.size / 2) {
						this.y = this.size / 2
					}
				}

				specDraw(x, y) {
					const offsetTime = (Date.now() - this.lastTime) / 500
					const _x = x - this.x
					const _y = y - this.y

					this.x = Math.abs(_x) > 0.1 ? this.x + _x * offsetTime : x
					this.y = Math.abs(_y) > 0.1 ? this.y + _y * offsetTime : y

					this._draw()
				}
				randDraw() {
					if (this.move) {
						this.overflow()

						const offsetTime = (Date.now() - this.lastTime) / 1000
						this.x += this.speedX * offsetTime
						this.y += this.speedY * offsetTime
					}
					this._draw()
				}

				_draw() {
					coverCtx.beginPath()
					coverCtx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2)
					coverCtx.fillStyle = '#fff'
					coverCtx.fill()

					this.lastTime = Date.now()
				}
			}
			class Graph {
				constructor(maxPoints, pointSize, maxDistance) {
					this.drawPoint = { method: 'random', fn: undefined }
					this.maxDistance = maxDistance
					this.maxPoints = maxPoints
					this.points = new Array(maxPoints).fill(0).map(() => {
						return new Point(pointSize)
					})
				}

				changeSpeedX(speed) {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedX = speed
					}
				}
				changeSpeedY(speed) {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedY = speed
					}
				}
				recoverySpeed() {
					for (let p = 0; p < this.maxPoints; p++) {
						this.points[p].speedX = getRandom(-50, 50)
						this.points[p].speedY = getRandom(-50, 50)
					}
				}

				/**
				 * @param {String} method rebound: 反彈, arroundY: Y軸環繞, arroundX: X軸環繞
				 */
				overflow(method) {
					for (let p = 0; p < this.maxPoints; p++) {
						if (method === 'rebound') {
							this.points[p].overflow = this.points[p].rebound
						}
						if (method === 'arroundY') {
							this.points[p].overflow = this.points[p].arroundY
						}
					}
				}

				/**
				 * @param {String} formation go: 正四方實心隊形, menu: 垂直矩形中空靠左隊形
				 * @param {Number} width 關鍵邊長的長度
				 */
				align(formation, width) {
					if (formation === 'go') {
						this.drawPoint.method = 'specific'
						this.drawPoint.fn = () => {
							const min = Math.min(banner.width, banner.height)
							const gap = min / (width + 1)
							let marginX = 0
							let marginY = 0
							if (min === banner.width) {
								marginX = gap
								marginY =
									(banner.height - gap * (width - 1)) / 2
							} else {
								marginX = (banner.width - gap * (width - 1)) / 2
								marginY = gap
							}
							for (let y = 0; y < width; y++) {
								for (let x = 0; x < width; x++) {
									const _x = marginX + x * gap
									const _y = marginY + y * gap
									this.points[y * width + x].specDraw(_x, _y)
								}
							}
						}
					}

					//去頭去尾去第二，剩餘三角排列
					if (formation === 'menu') {
						this.drawPoint.method = 'specific'
						this.drawPoint.fn = () => {
							const _h = width * 2 + 3
							const gap = banner.height / (_h + 1)
							const marginY = gap / 2
							const marginX = gap * 3
							for (let y = 0; y < _h; y++) {
								for (let x = 0; x < 2; x++) {
									const _isOdd = y % 2 !== 0
									if (y === 0 || y === _h - 1) {
										const _x = marginX + (1 + x * 2) * gap
										const _y = marginY + y * gap
										let i = undefined

										if (y === 0) i = 0
										else i = Math.ceil(y * 1.5) + 1
										this.points[i + x].specDraw(_x, _y)
									} else if (y === 1) {
										const _x = marginX + x * 4 * gap
										const _y = marginY + gap
										this.points[2 + x].specDraw(_x, _y)
									} else {
										if (!_isOdd) {
											const _x = marginX + gap * 2
											const _y = marginY + gap * y
											const i =
												4 + Math.ceil((y - 2) * 1.5)
											this.points[i].specDraw(_x, _y)

											continue
										} else {
											const _x = marginX + x * 4 * gap
											const _y = marginY + gap * y
											const i =
												5 + Math.floor((y - 3) * 1.5)
											this.points[i + x].specDraw(_x, _y)
										}
									}
								}
							}
						}
					}
				}
				random() {
					this.drawPoint = { method: 'random', fn: undefined }
				}

				draw() {
					coverCtx.clearRect(0, 0, banner.width, banner.height)
					requestAnimationFrame(() => {
						return this.draw()
					})

					for (let s = 0; s < this.maxPoints; s++) {
						for (let e = s + 1; e < this.maxPoints; e++) {
							this._drawLine(s, e)
						}
					}

					if (this.drawPoint.method === 'random') {
						for (let s = 0; s < this.maxPoints; s++) {
							this.points[s].randDraw()
						}
					}
					if (this.drawPoint.method === 'specific') {
						this.drawPoint.fn()
					}
				}

				animateStart() {
					this.draw()
					for (let s = 0; s < this.maxPoints; s++) {
						this.points[s].move = true
					}
				}
				animateStop() {
					for (let s = 0; s < this.maxPoints; s++) {
						this.points[s].move = false
					}
				}

				/**
				 * @param {number} start 起始的points[索引]
				 * @param {number} end 結束的points[索引]
				 */
				_drawLine(start, end) {
					const _x = this.points[start].x - this.points[end].x
					const _y = this.points[start].y - this.points[end].y
					const distance = Math.sqrt(
						Math.abs(_x ** 2) + Math.abs(_y ** 2)
					)
					const opacity = 1 - distance / this.maxDistance

					coverCtx.beginPath()
					coverCtx.moveTo(this.points[start].x, this.points[start].y)
					coverCtx.lineTo(this.points[end].x, this.points[end].y)
					coverCtx.closePath()
					coverCtx.lineWidth = 1
					coverCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`
					coverCtx.stroke()
				}
			}

			function getRandom(min, max) {
				return Math.floor(Math.random() * (max - min + 1) + min)
			}

			const graph = new Graph(MAX_POINTS, POINT_SIZE, MAX_DISTANCE)
			const position = {} // { element: { top, bottom, width, height }, ... }
			CoverInit()
			function CoverInit() {
				banner.width = window.innerWidth
				banner.height = window.innerHeight

				graph.animateStart()

				const coverX = banner.clientWidth
				const coverY = banner.clientHeight
				// go.style.top =
				// 	getRandom(50, coverY - go.clientHeight - 50) + 'px'
				// go.style.left =
				// 	getRandom(50, coverX - go.clientWidth - 50) + 'px'
				// ElementAni(go)
				// minesweeper.style.top =
				// 	getRandom(50, coverY - minesweeper.clientHeight - 50) + 'px'
				// minesweeper.style.left =
				// 	getRandom(50, coverX - minesweeper.clientWidth - 50) + 'px'
				// fireworks.style.top =
				// 	getRandom(50, coverY - fireworks.clientHeight - 50) + 'px'
				// fireworks.style.left =
				// 	getRandom(50, coverX - fireworks.clientWidth - 50) + 'px'
				// menuSur.style.top =
				// 	getRandom(50, coverY - menuSur.clientHeight - 50) + 'px'
				// menuSur.style.left =
				// 	getRandom(50, coverX - menuSur.clientWidth - 50) + 'px'
				// ElementAni(menuSur)
				// scrollAni.style.top =
				// 	getRandom(50, coverY - scrollAni.clientHeight - 50) + 'px'
				// scrollAni.style.left =
				// 	getRandom(50, coverX - scrollAni.clientWidth - 50) + 'px'
				// ElementAni(scrollAni)
				// scrollSli.style.top =
				// 	getRandom(50, coverY - scrollSli.clientHeight - 50) + 'px'
				// scrollSli.style.left =
				// 	getRandom(50, coverX - scrollSli.clientWidth - 50) + 'px'
				// ElementAni(scrollSli)
				// web.style.top =
				// 	getRandom(50, coverY - web.clientHeight - 50) + 'px'
				// web.style.left =
				// 	getRandom(50, coverX - web.clientWidth - 50) + 'px'

				cards.forEach((element) => {
					const x = getRandom(
						50,
						banner.clientWidth - element.offsetWidth - 50
					)
					const y = getRandom(
						50,
						banner.clientHeight - element.offsetHeight - 50
					)
					element.style.transform = `translate(${x}px, ${y}px)`
					const _c = {
						top: y,
						left: x,
						width: element.offsetWidth,
						height: element.offsetHeight,
					}
					position[element.id] = _c

					element.onclick = () => {
						location = '#' + element.id.slice(1)
					}
					element.onmouseenter = () => {
						graph.align(element.id, goSidePoint)
					}
					element.onmouseleave = () => {
						graph.random()
					}
				})
				ElementAni()
			}

			function ElementAni() {
				const SPEED = 50
				let lastTime = Date.now()
				const animate = {
					state: true,
					stop() {
						if (this.state) this.state = false
					},
					start() {
						if (!this.state) {
							this.state = true
							lastTime = Date.now()
							move()
						}
					},
				}
				class Position {
					constructor(target) {
						this.target = target
						this.left = position[target.id].left
						this.top = position[target.id].top
						this.width = position[target.id].width
						this.height = position[target.id].height
						this.signX = getRandom(0, 1) ? -1 : 1
						this.signY = getRandom(0, 1) ? -1 : 1
						this.speedX = getRandom(10, SPEED)
						this.speedY = Math.floor(
							Math.sqrt(SPEED ** 2 - this.speedX ** 2)
						)
					}
					moveX(offsetTime) {
						const clientWidth = document.body.clientWidth
						if (this.left <= 0) {
							this.signX = 1
							this.left = 1
						} else if (this.left >= clientWidth - this.width) {
							this.signX = -1
							this.left = clientWidth - this.width - 1
						} else
							this.left += this.speedX * offsetTime * this.signX

						position[this.target.id].left = this.left
					}
					moveY(offsetTime) {
						if (this.top <= 0) {
							this.signY = 1
							this.top = 1
						} else if (this.top >= banner.height - this.height) {
							this.signY = -1
							this.top = banner.height - this.height - 1
						} else this.top += this.speedY * offsetTime * this.signY

						position[this.target.id].top = this.top
					}
					collider() {
						for (let key in position) {
							if (key === this.target.id) continue

							const value = position[key]
							const _rX =
								_inRange(this.left + this.width, [
									value.left,
									value.left + value.width,
								]) ||
								_inRange(this.left, [
									value.left,
									value.left + value.width,
								])
							const _rY =
								_inRange(this.top, [
									value.top,
									value.top + value.height,
								]) ||
								_inRange(this.top + this.height, [
									value.top,
									value.top + value.height,
								])
							if (_rX && _rY) {
								const r = Math.abs(
									this.left + this.width - value.left
								)
								const l = Math.abs(
									this.left - (value.left + value.width)
								)
								const t = Math.abs(
									this.top - (value.top + value.height)
								)
								const b = Math.abs(
									this.top + this.height - value.top
								)

								const min = Math.min(r, l, t, b)
								if (r === min) {
									this.signX = -1
								} else if (l === min) {
									this.signX = 1
								}
								if (t === min) {
									this.signY = 1
								} else if (b === min) {
									this.signY = -1
								}
							}
						}
					}
				}
				const pos = []

				cards.forEach((target) => {
					pos.push(new Position(target))
				})
				;(function move() {
					if (animate.state) requestAnimationFrame(move)

					const offsetTime = (Date.now() - lastTime) / 1000
					for (const p of pos) {
						p.moveX(offsetTime)
						p.moveY(offsetTime)
						p.collider()
						p.target.style.transform = `translate(${p.left}px, ${p.top}px)`
					}
					lastTime = Date.now()
				})()

				/**
				 * @param {Number} value -
				 * @param {Array} block - [top, bottom] or [left, right]
				 * @returns {Boolean} -
				 */
				function _inRange(value, block) {
					return value >= block[0] && value <= block[1]
				}
			}
			// go.onclick = () => {
			// 	window.location = './Game/Go/'
			// }
			// go.onmouseenter = () => {
			// 	graph.align('go', goSidePoint)
			// }
			// go.onmouseleave = () => {
			// 	graph.random()
			// }
			// minesweeper.onclick = () => {
			// 	window.location = './Game/Minesweeper/'
			// }
			// minesweeper.onmouseenter = () => {
			// 	graph.align('go', goSidePoint)
			// }
			// minesweeper.onmouseleave = () => {
			// 	graph.random()
			// }
			// fireworks.onclick = () => {
			// 	window.location = './Canvas/Fireworks/'
			// }
			// fireworks.onmouseenter = () => {
			// 	graph.overflow('arroundY')
			// 	graph.changeSpeedY(-100)
			// }
			// fireworks.onmouseleave = () => {
			// 	graph.overflow('rebound')
			// 	graph.recoverySpeed()
			// }
			// menuSur.onclick = () => {
			// 	window.location = './Menu/Surround/'
			// }
			// menuSur.onmouseenter = () => {
			// 	graph.align('menu', menuSidePoint)
			// }
			// menuSur.onmouseleave = () => {
			// 	graph.random()
			// }
			// scrollAni.onclick = () => {
			// 	window.location = './Scrolling%20Effect/Animation/'
			// }
			// scrollAni.onmouseenter = () => {
			// 	graph.overflow('arroundY')
			// 	graph.changeSpeedY(-100)
			// }
			// scrollAni.onmouseleave = () => {
			// 	graph.overflow('rebound')
			// 	graph.recoverySpeed()
			// }
			// scrollSli.onclick = () => {
			// 	window.location = './Scrolling%20Effect/Slideshow/'
			// }
			// scrollSli.onmouseenter = () => {
			// 	graph.overflow('arroundY')
			// 	graph.changeSpeedY(-100)
			// }
			// scrollSli.onmouseleave = () => {
			// 	graph.overflow('rebound')
			// 	graph.recoverySpeed()
			// }
			// web.onclick = () => {
			// 	window.location = './WebDemo/Demo1/'
			// }
		</script>
	</body>
</html>
